
Στο φάκελο hashfile περιέχονται 4 αρχεία με main συναρτήσεις η περιγραφή των οποίων ακολουθεί:

	1. ht_main.c: Η default main() που μας δώθηκε, με μικρές αλλαγές,
	   ώστε να προσαρμοστεί στην ύπαρξη του πίνακα ανοιχτών αρχείων 
	   και ορισμένων πειραμάτων που θέλαμε να κάνουμε.
	   
	2. simple_main.c: Μια απλή main() που επιδεικνύει με λίγα δεδομένα,
	   όλες τις δυνατότητες του προγράμματος. Παρέχει prompt, στο οποίο
	   μπορεί να ζητηθεί συγκεκριμένη ενέργεια από το πληκτρολόγιο.
	   Κατά τις εισαγωγές, ελέγεται αν το id υπάρχει ήδη.
	   
	   Για λόγους συντομίας κώδικα, κάνουμε την παραδοχή πως τα δεδομένα
	   που εισάγονται από το χρήστη, ακολουθούν τα πρότυπα που του ζητά
	   το πρόγραμμα και δεν παραβαινουν τα όρια του record, ώστε να χωρούν
	   στις κατάλληλες θέσεις.
	   
	3. random_main.c: Μια "τυχαιοκρατική" main() που ανοίγει τυχαίο πλήθος
	   έως και MAX_OPEN_FILES/4 αρχείων και κάνει τυχαίες εγγραφές,
	   αναζητήσεις και διαγραφές πάνω τους με κινηματογραφικό τρόπο...
	   Το μέγιστο πλήθος εγγραφών ανά αρχείο είναι 3000 και τα buckets 
	   είναι σταθερά 17.
	   
	   ΣΗΜΕΙΩΣΗ: Προτείνεται πρώτα να την τρέξετε και μετά να διαβάσετε
	   τον κώδικά της, για πιο "ολοκληρωμένη" εμπειρία.
	   
	4. multi_main.c: Μια ντετερμινιστική main() που ανοίγει MAX_OPEN_FILES
	   αρχεία με 5 έως 19 buckets, εισάγει 5000 εγγραφές κατανεμημένες
	   σε αυτά και έπειτα κάνει αναζητήσεις για να βρει σε ποιο από όλα τα
	   αρχεία βρίσκεται η κάθε μία και να την απαλείψει.
	   
	   Υλοποιήθηκε ως ένα σενάριο που "φέρνει τη δομή στα όριά της" με
	   τις επαναλαμβανόμενες αναγνώσεις μέσω της HT_SeekEntry() για να 
	   βρει, να τυπώσει και να διαγράψει τις εγγραφές ανάμεσα στην 
	   πληθώρα αρχείων.
	   
	   Για να δειχθεί πως ακόμη και το ίδιο αρχείο, δύναται να είναι ανοικτό
	   περισσότερες από μία φορές, ακόμη και ταυτόχρονα, οι δύο τελευταίες
	   θέσεις του global πίνακά στο multi_main.c, αντιστοιχούν στην
	   πραγματικότητα στο ίδιο αρχείο. Έτσι, στην προτελευταία θέση
	   παρατηρούνται μόνο εισαγωγές, ενώ στην τελευταία μόνο ισοπληθείς
	   εκτυπώσεις και διαγραφές.
	   
Τα εκτελέσιμά τους, παράγονται με τις εντολες make simple, make random και make multi αντίστοιχα.

ΣΗΜΕΙΩΣΗ: Τα ονόματα των παραγόμενων αρχείων της κάθε main(), δίνονται στατικά στo αντίστοιχο .c . 
Έχουμε κάνει την παραδοχή πως MAX_OPEN_FILES<=20. Έτσι, για μεγαλύτερο πλήθος αρχείων ΠΡΕΠΕΙ
να τροποποιηθεί ο αντίστοιχος πίνακας ονομάτων, για να έχει περισσότερες θέσεις/ονόματα!

	   
Σε όλες τις main(), κατά το κλείσιμο των ανοικτών αρχείων, τυπώνονται κάποια στατιστικά για
καθένα από αυτά, με βάση τον πίνακα ανοικτών αρχείων.

Ο εν λόγω πίνακας, αποτελείται από MAX_OPEN_FILES δομές OFI (Open Files Info) όπως τις έχουμε
ορίσει στο hash_file.h και περιέχουν τα εξής μέλη τύπου int:
	
	-filedesc: το αναγνωριστικό αρχείου που αποδίδεται από το επίπεδο BF.
	-buckets: το πλήθος των buckets στο hashtable του αρχείου.
	-inserted: το σύνολο των εγγραφών που εισήχθησαν επιτυχημένα στο αρχείο.
	-lookups: το σύνολο των αναζητήσεων δωσμένου id που πραγματοποιήθηκαν στο αρχείο.
	-deleted: το σύνολο των επιτυχημένων διαγραφών στο αρχείο.
	
Πέρα από τον ορισμό της παραπάνω δομής, στο hash_file.h έχουμε δηλώσει και τον ίδιο το global
πίνακα τύπου OFI, τον οποίο αρχικόποιούμε στην εκάστοτε main. 

Επιπλέον, στο ίδιο αρχείο έχουμε εισάγει και το πρώτυπο μιας δικής μας συνάρτησης, ως εξής:

	int HT_SeekEntry(int, int, int*, int*, Record*);
	
	Η HT_SeekEntry() δέχεται σαν ορίσματα μια θέση στον πίνακα ανοικτών αρχείων και ένα id
	προς αναζήτηση και εφόσον υπάρχει εγγραφή με το εν λόγω id, αποδίδει στην καλούσα
	συνάρτηση μέσω όσων δεικτών της έχει δώσει, το αναγνωριστικό του μπλοκ στο οποίο 
	βρίσκεται η εγγραφή, τη θεση της μέσα στο μπλοκ και την ίδια την εγγραφή.
	Το return value της είναι 1, αν η εγγραφή βρεθεί και 0 αν δε βρεθεί.
	
	Υλοποιήθηκε, καθώς η μακροσκελής διαδικασία που εκτελεί, πραγματοποιείται αυτούσια 
	τόσο στην HT_PrintAllEntries(), όσο και στην HT_DeleteEntry(). Η πρώτη την καλεί δίνοντας
	της τιμή στο δείκτη τύπου record, ώστε να αποφευχθεί ένα περιττό read, μιας και την 
	αφορά μόνο το περιεχόμενο της εγγραφής, ενώ η δεύτερη την καλεί με τιμή δείκτη σε εγγραφή
	NULL, καθώς χρειάζεται τη θέση και όχι το περιεχόμενο της εγγραφής, αφού κάνει write
	πάνω της, την τελευταία εγγραφή του bucket. Επιπλέον, μας είναι χρήσιμη στις δύο από τις
	τρεις main() που υλοποιήσαμε.
	
Αντίστοιχα, επιλέξαμε να μην κάνουμε ξεχωριστή ρουτίνα -έστω και inline- για τη συνάρτηση
κατακερματισμού, στο πλαίσιο της δεδομένης εργασίας, καθώς αποτελείται από μόλις μία εντολή
που χρησιμοποιείται συνολικά τρεις φορές σε όλο τον κώδικα.
	   
Το πρώτο μπλοκ κάθε αρχείου [block 0] περιέχει μόνο το αναγνωριστικό "HashFile" και έναν 
ακέραιο για το πλήθος των buckets του hashtable.

Τα επόμενα μπλοκ ξεκινώντας από το δεύτερο [block 1] χρησιμεύουν για την αποθήκευση του
hashtable και το πλήθος τους μεταβάλλεται ανάλογα με τον αριθμό των buckets. Τυπικά, με
μέγεθος μπλοκ 512 bytes και sizeof(int) 4 bytes, ένα μπλοκ μπορεί να φιλοξενήσει 64 buckets.

Έπεται, ότι κάθε bucket αποτελείται από δύο ακέραιους, που είναι κατα σειρά ο αναγνωριστικός
αριθμός του πρώτου και του τελευταίου μπλοκ δεδομένων που έχουν δεσμευτεί για το εν λόγω 
bucket με την παρακάτω μορφή:

	<----bucket0----> <----bucket1---->
	+--------+-------+--------+-------+---+
	| first0 | last0 | first1 | last1 |...|
	+--------+-------+--------+-------+---+

Όλα τα μπλοκ του hashtable δεσμεύονται και αρχικοποιούνται κατά την HT_CreateIndex(). Όλα όσα
ακολουθούν, είναι block δεδομένων.

Τα μπλοκ δεδομένων έχουν την κάτωθι μορφή:

	+-----+-----+-----+---------+---------+---+
	| int | int | int | record1 | record2 |...|
	+-----+-----+-----+---------+---------+---+
	
	*Ο πρώτος ακέραιος συμβολίζει το πλήθος των περιεχομένων εγγραφών.
	*Ο δεύτερος συμβολίζει το αναγνωριστικό του προηγούμενου block στην αλυσίδα του bucket.
	*Ο τρίτος συμβολίζει το αναγνωριστικό του επόμενου block στην αλυσίδσα του bucket.
	
	Φυσιολογικά, ακολουθούν τα records.
	
Μιάς και τα data blocks ξεκινούν τουλάχιστον από το block με αναγνωριστικό 2, η αρχικοποίηση
όλων των "δεικτών" σε blocks, τόσο στο hashtable, όσο και στα block δεδομένων γίνεται σε
τιμή 0 και με βάση αυτή γίνονται οι κατάλληλοι έλεγχοι περιεχομένου.
	
Σε όλη την άσκηση, κάθε κομμάτι μνήμης που δεσμεύεται δυναμικά, αποδεσμεύται κατάλληλα, 
όλα τα μπλοκ με αλλαγή στα δεδομένα τους μαρκάρονται ώστε να αποθηκευθούν οι αλλαγές και 
κάθε μπλοκ που διαβάζεται γίνεται Unpin, ώστε να μπορεί να αντικατασταθεί στη μνήμη.

Όπως έχει αναφερθεί και στο e-class, το id θεωρείται μοναδικό. Έτσι, στην αναζήτηση μέσω id, 
η HT_PrintAllEntries(), καλέι την HT_SeekEntry() ώστε να πάρει και να τυπώσει μοναδική εγγραφή,
εφ'όσον αυτή υπάρχει. Το ίδιο ισχύει και με την HT_DeleteEntry(). Σε περίπτωση που δωθεί στην
HT_PrintAllEntries() όρισμα NULL, τότε αυτή τυπώνει όλες τις εγγραφές, γκρουπαρισμένες ανα bucket.
	 
Κατά τη διαδικασία επαναλαμβανόμενων διαγραφών, αν ένα μπλοκ αδειάσει, όπως έχει αναφερθεί και
στο e-class, διατηρείται στην αλυσίδα, ώσπου να ξαναγεμίσει. Κατάλληλες περιπτώσεις έχουν 
ληφθεί υπ'όψιν τόσο στην HT_InsertEntry(), όσο και στην HT_DeleteEntry().

Τέλος, lookup θεωρείται κάθε αναζήτηση με δεδομένο id, όχι όμως και η εκτύπωση του συνόλου των
εγγραφών.


